{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/home/one/NIN/nin_0.3.2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar protocol = require('./constants');\n\nvar empty = Buffer.allocUnsafe(0);\nvar zeroBuf = Buffer.from([0]);\n\nvar numbers = require('./numbers');\n\nvar nextTick = require('process-nextick-args').nextTick;\n\nvar debug = require('debug')('mqtt-packet:writeToStream');\n\nvar numCache = numbers.cache;\nvar generateNumber = numbers.generateNumber;\nvar generateCache = numbers.generateCache;\nvar genBufVariableByteInt = numbers.genBufVariableByteInt;\nvar generate4ByteBuffer = numbers.generate4ByteBuffer;\nvar writeNumber = writeNumberCached;\nvar toGenerate = true;\n\nfunction generate(packet, stream, opts) {\n  debug('generate called');\n\n  if (stream.cork) {\n    stream.cork();\n    nextTick(uncork, stream);\n  }\n\n  if (toGenerate) {\n    toGenerate = false;\n    generateCache();\n  }\n\n  debug('generate: packet.cmd: %s', packet.cmd);\n\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts);\n\n    case 'connack':\n      return connack(packet, stream, opts);\n\n    case 'publish':\n      return publish(packet, stream, opts);\n\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts);\n\n    case 'subscribe':\n      return subscribe(packet, stream, opts);\n\n    case 'suback':\n      return suback(packet, stream, opts);\n\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts);\n\n    case 'unsuback':\n      return unsuback(packet, stream, opts);\n\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts);\n\n    case 'disconnect':\n      return disconnect(packet, stream, opts);\n\n    case 'auth':\n      return auth(packet, stream, opts);\n\n    default:\n      stream.emit('error', new Error('Unknown command'));\n      return false;\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\n\n\nObject.defineProperty(generate, 'cacheNumbers', {\n  get: function get() {\n    return writeNumber === writeNumberCached;\n  },\n  set: function set(value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n      writeNumber = writeNumberCached;\n    } else {\n      toGenerate = false;\n      writeNumber = writeNumberGenerated;\n    }\n  }\n});\n\nfunction uncork(stream) {\n  stream.uncork();\n}\n\nfunction connect(packet, stream, opts) {\n  var settings = packet || {};\n  var protocolId = settings.protocolId || 'MQTT';\n  var protocolVersion = settings.protocolVersion || 4;\n  var will = settings.will;\n  var clean = settings.clean;\n  var keepalive = settings.keepalive || 0;\n  var clientId = settings.clientId || '';\n  var username = settings.username;\n  var password = settings.password;\n  /* mqtt5 new oprions */\n\n  var properties = settings.properties;\n  if (clean === undefined) clean = true;\n  var length = 0; // Must be a string and non-falsy\n\n  if (!protocolId || typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n    stream.emit('error', new Error('Invalid protocolId'));\n    return false;\n  } else length += protocolId.length + 2; // Must be 3 or 4 or 5\n\n\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'));\n    return false;\n  } else length += 1; // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n\n\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {\n    length += Buffer.byteLength(clientId) + 2;\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n      return false;\n    }\n\n    if (clean * 1 === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n      return false;\n    }\n  } // Must be a two byte number\n\n\n  if (typeof keepalive !== 'number' || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'));\n    return false;\n  } else length += 2; // Connect flags\n\n\n  length += 1; // Properties\n\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // If will exists...\n\n\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'));\n      return false;\n    } // It must have topic typeof string\n\n\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'));\n      return false;\n    } else {\n      length += Buffer.byteLength(will.topic) + 2;\n    } // Payload\n\n\n    length += 2; // payload length\n\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload);\n        } else {\n          length += will.payload.length;\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'));\n        return false;\n      }\n    } // will properties\n\n\n    var willProperties = {};\n\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties);\n\n      if (!willProperties) {\n        return false;\n      }\n\n      length += willProperties.length;\n    }\n  } // Username\n\n\n  var providedUsername = false;\n\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true;\n      length += Buffer.byteLength(username) + 2;\n    } else {\n      stream.emit('error', new Error('Invalid username'));\n      return false;\n    }\n  } // Password\n\n\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'));\n      return false;\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2;\n    } else {\n      stream.emit('error', new Error('Invalid password'));\n      return false;\n    }\n  } // Generate header\n\n\n  stream.write(protocol.CONNECT_HEADER); // Generate length\n\n  writeVarByteInt(stream, length); // Generate protocol ID\n\n  writeStringOrBuffer(stream, protocolId);\n\n  if (settings.bridgeMode) {\n    protocolVersion += 128;\n  }\n\n  stream.write(protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3); // Connect flags\n\n  var flags = 0;\n  flags |= username != null ? protocol.USERNAME_MASK : 0;\n  flags |= password != null ? protocol.PASSWORD_MASK : 0;\n  flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n  flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n  flags |= will ? protocol.WILL_FLAG_MASK : 0;\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n  stream.write(Buffer.from([flags])); // Keepalive\n\n  writeNumber(stream, keepalive); // Properties\n\n  if (protocolVersion === 5) {\n    propertiesData.write();\n  } // Client ID\n\n\n  writeStringOrBuffer(stream, clientId); // Will\n\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write();\n    }\n\n    writeString(stream, will.topic);\n    writeStringOrBuffer(stream, will.payload);\n  } // Username and password\n\n\n  if (username != null) {\n    writeStringOrBuffer(stream, username);\n  }\n\n  if (password != null) {\n    writeStringOrBuffer(stream, password);\n  } // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n\n\n  return true;\n}\n\nfunction connack(packet, stream, opts) {\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var rc = version === 5 ? settings.reasonCode : settings.returnCode;\n  var properties = settings.properties;\n  var length = 2; // length of rc and sessionHeader\n  // Check return code\n\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'));\n    return false;\n  } // mqtt5 properties\n\n\n  var propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  }\n\n  stream.write(protocol.CONNACK_HEADER); // length\n\n  writeVarByteInt(stream, length);\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n  stream.write(Buffer.from([rc]));\n\n  if (propertiesData != null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction publish(packet, stream, opts) {\n  debug('publish: packet: %o', packet);\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var qos = settings.qos || 0;\n  var retain = settings.retain ? protocol.RETAIN_MASK : 0;\n  var topic = settings.topic;\n  var payload = settings.payload || empty;\n  var id = settings.messageId;\n  var properties = settings.properties;\n  var length = 0; // Topic must be a non-empty string or Buffer\n\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else if (Buffer.isBuffer(topic)) length += topic.length + 2;else {\n    stream.emit('error', new Error('Invalid topic'));\n    return false;\n  } // Get the payload length\n\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else length += payload.length; // Message ID must a number if qos > 0\n\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else if (qos) length += 2; // mqtt5 properties\n\n\n  var propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]); // Remaining length\n\n  writeVarByteInt(stream, length); // Topic\n\n  writeNumber(stream, byteLength(topic));\n  stream.write(topic); // Message ID\n\n  if (qos > 0) writeNumber(stream, id); // Properties\n\n  if (propertiesData != null) {\n    propertiesData.write();\n  } // Payload\n\n\n  debug('publish: payload: %o', payload);\n  return stream.write(payload);\n}\n/* Puback, pubrec, pubrel and pubcomp */\n\n\nfunction confirmation(packet, stream, opts) {\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var type = settings.cmd || 'puback';\n  var id = settings.messageId;\n  var dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n  var qos = 0;\n  var reasonCode = settings.reasonCode;\n  var properties = settings.properties;\n  var length = version === 5 ? 3 : 2;\n  if (type === 'pubrel') qos = 1; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } // properies mqtt 5\n\n\n  var propertiesData = null;\n\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n      if (!propertiesData) {\n        return false;\n      }\n\n      length += propertiesData.length;\n    }\n  } // Header\n\n\n  stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // reason code in header\n\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]));\n  } // properies mqtt 5\n\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction subscribe(packet, stream, opts) {\n  debug('subscribe: packet: ');\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var dup = settings.dup ? protocol.DUP_MASK : 0;\n  var id = settings.messageId;\n  var subs = settings.subscriptions;\n  var properties = settings.properties;\n  var length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else length += 2; // properies mqtt 5\n\n\n  var propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Check subscriptions\n\n\n  if (typeof subs === 'object' && subs.length) {\n    for (var i = 0; i < subs.length; i += 1) {\n      var itopic = subs[i].topic;\n      var iqos = subs[i].qos;\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n        return false;\n      }\n\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n        return false;\n      }\n\n      if (version === 5) {\n        var nl = subs[i].nl || false;\n\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n          return false;\n        }\n\n        var rap = subs[i].rap || false;\n\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n          return false;\n        }\n\n        var rh = subs[i].rh || 0;\n\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n          return false;\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'));\n    return false;\n  } // Generate header\n\n\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER);\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Generate length\n\n  writeVarByteInt(stream, length); // Generate message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  var result = true; // Generate subs\n\n  var _iterator = _createForOfIteratorHelper(subs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var sub = _step.value;\n      var jtopic = sub.topic;\n      var jqos = sub.qos;\n      var jnl = +sub.nl;\n      var jrap = +sub.rap;\n      var jrh = sub.rh;\n      var joptions = void 0; // Write topic string\n\n      writeString(stream, jtopic); // options process\n\n      joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n\n      if (version === 5) {\n        joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n        joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n        joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n      } // Write options\n\n\n      result = stream.write(Buffer.from([joptions]));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result;\n}\n\nfunction suback(packet, stream, opts) {\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var id = settings.messageId;\n  var granted = settings.granted;\n  var properties = settings.properties;\n  var length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else length += 2; // Check granted qos vector\n\n\n  if (typeof granted === 'object' && granted.length) {\n    for (var i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'));\n        return false;\n      }\n\n      length += 1;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'));\n    return false;\n  } // properies mqtt 5\n\n\n  var propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // header\n\n\n  stream.write(protocol.SUBACK_HEADER); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return stream.write(Buffer.from(granted));\n}\n\nfunction unsubscribe(packet, stream, opts) {\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var id = settings.messageId;\n  var dup = settings.dup ? protocol.DUP_MASK : 0;\n  var unsubs = settings.unsubscriptions;\n  var properties = settings.properties;\n  var length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else {\n    length += 2;\n  } // Check unsubs\n\n\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (var i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'));\n        return false;\n      }\n\n      length += Buffer.byteLength(unsubs[i]) + 2;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'));\n    return false;\n  } // properies mqtt 5\n\n\n  var propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  } // Unsubs\n\n\n  var result = true;\n\n  for (var j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j]);\n  }\n\n  return result;\n}\n\nfunction unsuback(packet, stream, opts) {\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var id = settings.messageId;\n  var dup = settings.dup ? protocol.DUP_MASK : 0;\n  var granted = settings.granted;\n  var properties = settings.properties;\n  var type = settings.cmd;\n  var qos = 0;\n  var length = 2; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } // Check granted\n\n\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (var i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'));\n          return false;\n        }\n\n        length += 1;\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'));\n      return false;\n    }\n  } // properies mqtt 5\n\n\n  var propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  } // payload\n\n\n  if (version === 5) {\n    stream.write(Buffer.from(granted));\n  }\n\n  return true;\n}\n\nfunction emptyPacket(packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd]);\n}\n\nfunction disconnect(packet, stream, opts) {\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var reasonCode = settings.reasonCode;\n  var properties = settings.properties;\n  var length = version === 5 ? 1 : 0; // properies mqtt 5\n\n  var propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(Buffer.from([protocol.codes.disconnect << 4])); // Length\n\n  writeVarByteInt(stream, length); // reason code in header\n\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]));\n  } // properies mqtt 5\n\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction auth(packet, stream, opts) {\n  var version = opts ? opts.protocolVersion : 4;\n  var settings = packet || {};\n  var reasonCode = settings.reasonCode;\n  var properties = settings.properties;\n  var length = version === 5 ? 1 : 0;\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet')); // properies mqtt 5\n\n  var propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n  if (!propertiesData) {\n    return false;\n  }\n\n  length += propertiesData.length; // Header\n\n  stream.write(Buffer.from([protocol.codes.auth << 4])); // Length\n\n  writeVarByteInt(stream, length); // reason code in header\n\n  stream.write(Buffer.from([reasonCode])); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\n\nvar varByteIntCache = {};\n\nfunction writeVarByteInt(stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(\"Invalid variable byte integer: \".concat(num)));\n    return false;\n  }\n\n  var buffer = varByteIntCache[num];\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num);\n    if (num < 16384) varByteIntCache[num] = buffer;\n  }\n\n  debug('writeVarByteInt: writing to stream: %o', buffer);\n  return stream.write(buffer);\n}\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeString(stream, string) {\n  var strlen = Buffer.byteLength(string);\n  writeNumber(stream, strlen);\n  debug('writeString: %s', string);\n  return stream.write(string, 'utf8');\n}\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeStringPair(stream, name, value) {\n  writeString(stream, name);\n  writeString(stream, value);\n}\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeNumberCached(stream, number) {\n  debug('writeNumberCached: number: %d', number);\n  debug('writeNumberCached: %o', numCache[number]);\n  return stream.write(numCache[number]);\n}\n\nfunction writeNumberGenerated(stream, number) {\n  var generatedNumber = generateNumber(number);\n  debug('writeNumberGenerated: %o', generatedNumber);\n  return stream.write(generatedNumber);\n}\n\nfunction write4ByteNumber(stream, number) {\n  var generated4ByteBuffer = generate4ByteBuffer(number);\n  debug('write4ByteNumber: %o', generated4ByteBuffer);\n  return stream.write(generated4ByteBuffer);\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\n\n\nfunction writeStringOrBuffer(stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite);\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length);\n    stream.write(toWrite);\n  } else writeNumber(stream, 0);\n}\n\nfunction getProperties(stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n      write: function write() {\n        writeProperties(stream, {}, 0);\n      }\n    };\n  }\n\n  var propertiesLength = 0;\n\n  function getLengthProperty(name, value) {\n    var type = protocol.propertiesTypes[name];\n    var length = 0;\n\n    switch (type) {\n      case 'byte':\n        {\n          if (typeof value !== 'boolean') {\n            stream.emit('error', new Error(\"Invalid \".concat(name, \": \").concat(value)));\n            return false;\n          }\n\n          length += 1 + 1;\n          break;\n        }\n\n      case 'int8':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xff) {\n            stream.emit('error', new Error(\"Invalid \".concat(name, \": \").concat(value)));\n            return false;\n          }\n\n          length += 1 + 1;\n          break;\n        }\n\n      case 'binary':\n        {\n          if (value && value === null) {\n            stream.emit('error', new Error(\"Invalid \".concat(name, \": \").concat(value)));\n            return false;\n          }\n\n          length += 1 + Buffer.byteLength(value) + 2;\n          break;\n        }\n\n      case 'int16':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n            stream.emit('error', new Error(\"Invalid \".concat(name, \": \").concat(value)));\n            return false;\n          }\n\n          length += 1 + 2;\n          break;\n        }\n\n      case 'int32':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n            stream.emit('error', new Error(\"Invalid \".concat(name, \": \").concat(value)));\n            return false;\n          }\n\n          length += 1 + 4;\n          break;\n        }\n\n      case 'var':\n        {\n          // var byte integer is max 24 bits packed in 32 bits\n          if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n            stream.emit('error', new Error(\"Invalid \".concat(name, \": \").concat(value)));\n            return false;\n          }\n\n          length += 1 + Buffer.byteLength(genBufVariableByteInt(value));\n          break;\n        }\n\n      case 'string':\n        {\n          if (typeof value !== 'string') {\n            stream.emit('error', new Error(\"Invalid \".concat(name, \": \").concat(value)));\n            return false;\n          }\n\n          length += 1 + 2 + Buffer.byteLength(value.toString());\n          break;\n        }\n\n      case 'pair':\n        {\n          if (typeof value !== 'object') {\n            stream.emit('error', new Error(\"Invalid \".concat(name, \": \").concat(value)));\n            return false;\n          }\n\n          length += Object.getOwnPropertyNames(value).reduce(function (result, name) {\n            var currentValue = value[name];\n\n            if (Array.isArray(currentValue)) {\n              result += currentValue.reduce(function (currentLength, value) {\n                currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString());\n                return currentLength;\n              }, 0);\n            } else {\n              result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n            }\n\n            return result;\n          }, 0);\n          break;\n        }\n\n      default:\n        {\n          stream.emit('error', new Error(\"Invalid property \".concat(name, \": \").concat(value)));\n          return false;\n        }\n    }\n\n    return length;\n  }\n\n  if (properties) {\n    for (var propName in properties) {\n      var propLength = 0;\n      var propValueLength = 0;\n      var propValue = properties[propName];\n\n      if (Array.isArray(propValue)) {\n        for (var valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex]);\n\n          if (!propValueLength) {\n            return false;\n          }\n\n          propLength += propValueLength;\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue);\n\n        if (!propValueLength) {\n          return false;\n        }\n\n        propLength = propValueLength;\n      }\n\n      if (!propLength) return false;\n      propertiesLength += propLength;\n    }\n  }\n\n  var propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength));\n  return {\n    length: propertiesLengthLength + propertiesLength,\n    write: function write() {\n      writeProperties(stream, properties, propertiesLength);\n    }\n  };\n}\n\nfunction getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n  var mayEmptyProps = ['reasonString', 'userProperties'];\n  var maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n  var propertiesData = getProperties(stream, properties);\n\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      var currentMayEmptyProp = mayEmptyProps.shift();\n\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp];\n        propertiesData = getProperties(stream, properties);\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return propertiesData;\n}\n\nfunction writeProperty(stream, propName, value) {\n  var type = protocol.propertiesTypes[propName];\n\n  switch (type) {\n    case 'byte':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        stream.write(Buffer.from([+value]));\n        break;\n      }\n\n    case 'int8':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        stream.write(Buffer.from([value]));\n        break;\n      }\n\n    case 'binary':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeStringOrBuffer(stream, value);\n        break;\n      }\n\n    case 'int16':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeNumber(stream, value);\n        break;\n      }\n\n    case 'int32':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        write4ByteNumber(stream, value);\n        break;\n      }\n\n    case 'var':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeVarByteInt(stream, value);\n        break;\n      }\n\n    case 'string':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeString(stream, value);\n        break;\n      }\n\n    case 'pair':\n      {\n        Object.getOwnPropertyNames(value).forEach(function (name) {\n          var currentValue = value[name];\n\n          if (Array.isArray(currentValue)) {\n            currentValue.forEach(function (value) {\n              stream.write(Buffer.from([protocol.properties[propName]]));\n              writeStringPair(stream, name.toString(), value.toString());\n            });\n          } else {\n            stream.write(Buffer.from([protocol.properties[propName]]));\n            writeStringPair(stream, name.toString(), currentValue.toString());\n          }\n        });\n        break;\n      }\n\n    default:\n      {\n        stream.emit('error', new Error(\"Invalid property \".concat(propName, \" value: \").concat(value)));\n        return false;\n      }\n  }\n}\n\nfunction writeProperties(stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength);\n\n  for (var propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      var value = properties[propName];\n\n      if (Array.isArray(value)) {\n        for (var valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex]);\n        }\n      } else {\n        writeProperty(stream, propName, value);\n      }\n    }\n  }\n}\n\nfunction byteLength(bufOrString) {\n  if (!bufOrString) return 0;else if (bufOrString instanceof Buffer) return bufOrString.length;else return Buffer.byteLength(bufOrString);\n}\n\nfunction isStringOrBuffer(field) {\n  return typeof field === 'string' || field instanceof Buffer;\n}\n\nmodule.exports = generate;","map":{"version":3,"sources":["/home/one/node_modules/mqtt-packet/writeToStream.js"],"names":["protocol","require","empty","Buffer","allocUnsafe","zeroBuf","from","numbers","nextTick","debug","numCache","cache","generateNumber","generateCache","genBufVariableByteInt","generate4ByteBuffer","writeNumber","writeNumberCached","toGenerate","generate","packet","stream","opts","cork","uncork","cmd","connect","connack","publish","confirmation","subscribe","suback","unsubscribe","unsuback","emptyPacket","disconnect","auth","emit","Error","Object","defineProperty","get","set","value","keys","length","writeNumberGenerated","settings","protocolId","protocolVersion","will","clean","keepalive","clientId","username","password","properties","undefined","isBuffer","byteLength","propertiesData","getProperties","topic","payload","willProperties","providedUsername","isStringOrBuffer","write","CONNECT_HEADER","writeVarByteInt","writeStringOrBuffer","bridgeMode","VERSION131","VERSION132","VERSION4","VERSION5","VERSION3","flags","USERNAME_MASK","PASSWORD_MASK","retain","WILL_RETAIN_MASK","qos","WILL_QOS_SHIFT","WILL_FLAG_MASK","CLEAN_SESSION_MASK","writeString","version","rc","reasonCode","returnCode","CONNACK_HEADER","sessionPresent","SESSIONPRESENT_HEADER","RETAIN_MASK","id","messageId","PUBLISH_HEADER","dup","type","DUP_MASK","getPropertiesByMaximumPacketSize","ACKS","subs","subscriptions","i","itopic","iqos","nl","rap","rh","SUBSCRIBE_HEADER","result","sub","jtopic","jqos","jnl","jrap","jrh","joptions","SUBSCRIBE_OPTIONS_QOS","SUBSCRIBE_OPTIONS_NL","SUBSCRIBE_OPTIONS_RAP","SUBSCRIBE_OPTIONS_RH","granted","SUBACK_HEADER","unsubs","unsubscriptions","UNSUBSCRIBE_HEADER","j","EMPTY","codes","varByteIntCache","num","VARBYTEINT_MAX","buffer","string","strlen","writeStringPair","name","number","generatedNumber","write4ByteNumber","generated4ByteBuffer","toWrite","writeProperties","propertiesLength","getLengthProperty","propertiesTypes","toString","getOwnPropertyNames","reduce","currentValue","Array","isArray","currentLength","propName","propLength","propValueLength","propValue","valueIndex","propertiesLengthLength","mayEmptyProps","maximumPacketSize","currentMayEmptyProp","shift","writeProperty","forEach","prototype","hasOwnProperty","call","bufOrString","field","module","exports"],"mappings":"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","sourcesContent":["const protocol = require('./constants')\nconst empty = Buffer.allocUnsafe(0)\nconst zeroBuf = Buffer.from([0])\nconst numbers = require('./numbers')\nconst nextTick = require('process-nextick-args').nextTick\nconst debug = require('debug')('mqtt-packet:writeToStream')\n\nconst numCache = numbers.cache\nconst generateNumber = numbers.generateNumber\nconst generateCache = numbers.generateCache\nconst genBufVariableByteInt = numbers.genBufVariableByteInt\nconst generate4ByteBuffer = numbers.generate4ByteBuffer\nlet writeNumber = writeNumberCached\nlet toGenerate = true\n\nfunction generate (packet, stream, opts) {\n  debug('generate called')\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n  debug('generate: packet.cmd: %s', packet.cmd)\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts)\n    case 'connack':\n      return connack(packet, stream, opts)\n    case 'publish':\n      return publish(packet, stream, opts)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts)\n    case 'subscribe':\n      return subscribe(packet, stream, opts)\n    case 'suback':\n      return suback(packet, stream, opts)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts)\n    case 'unsuback':\n      return unsuback(packet, stream, opts)\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts)\n    case 'disconnect':\n      return disconnect(packet, stream, opts)\n    case 'auth':\n      return auth(packet, stream, opts)\n    default:\n      stream.emit('error', new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get () {\n    return writeNumber === writeNumberCached\n  },\n  set (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (packet, stream, opts) {\n  const settings = packet || {}\n  const protocolId = settings.protocolId || 'MQTT'\n  let protocolVersion = settings.protocolVersion || 4\n  const will = settings.will\n  let clean = settings.clean\n  const keepalive = settings.keepalive || 0\n  const clientId = settings.clientId || ''\n  const username = settings.username\n  const password = settings.password\n  /* mqtt5 new oprions */\n  const properties = settings.properties\n\n  if (clean === undefined) clean = true\n\n  let length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.emit('error', new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4 or 5\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion >= 4) && (clientId || clean)) {\n    length += Buffer.byteLength(clientId) + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  // Properties\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    length += 2 // payload length\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload)\n        } else {\n          length += will.payload.length\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'))\n        return false\n      }\n    }\n    // will properties\n    var willProperties = {}\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties)\n      if (!willProperties) { return false }\n      length += willProperties.length\n    }\n  }\n\n  // Username\n  let providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.emit('error', new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.emit('error', new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n\n  if (settings.bridgeMode) {\n    protocolVersion += 128\n  }\n\n  stream.write(\n    protocolVersion === 131\n      ? protocol.VERSION131\n      : protocolVersion === 132\n        ? protocol.VERSION132\n        : protocolVersion === 4\n          ? protocol.VERSION4\n          : protocolVersion === 5\n            ? protocol.VERSION5\n            : protocol.VERSION3\n  )\n\n  // Connect flags\n  let flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Properties\n  if (protocolVersion === 5) {\n    propertiesData.write()\n  }\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write()\n    }\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode\n  const properties = settings.properties\n  let length = 2 // length of rc and sessionHeader\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'))\n    return false\n  }\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  // length\n  writeVarByteInt(stream, length)\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  stream.write(Buffer.from([rc]))\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction publish (packet, stream, opts) {\n  debug('publish: packet: %o', packet)\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const qos = settings.qos || 0\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0\n  const topic = settings.topic\n  const payload = settings.payload || empty\n  const id = settings.messageId\n  const properties = settings.properties\n\n  let length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.emit('error', new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeVarByteInt(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Properties\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n\n  // Payload\n  debug('publish: payload: %o', payload)\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const type = settings.cmd || 'puback'\n  const id = settings.messageId\n  const dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  let qos = 0\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 3 : 2\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n      if (!propertiesData) { return false }\n      length += propertiesData.length\n    }\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction subscribe (packet, stream, opts) {\n  debug('subscribe: packet: ')\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const id = settings.messageId\n  const subs = settings.subscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic\n      const iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      if (version === 5) {\n        const nl = subs[i].nl || false\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'))\n          return false\n        }\n        const rap = subs[i].rap || false\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'))\n          return false\n        }\n        const rh = subs[i].rh || 0\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'))\n          return false\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER)\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  let result = true\n\n  // Generate subs\n  for (const sub of subs) {\n    const jtopic = sub.topic\n    const jqos = sub.qos\n    const jnl = +sub.nl\n    const jrap = +sub.rap\n    const jrh = sub.rh\n    let joptions\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // options process\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0\n    }\n    // Write options\n    result = stream.write(Buffer.from([joptions]))\n  }\n\n  return result\n}\n\nfunction suback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const granted = settings.granted\n  const properties = settings.properties\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const unsubs = settings.unsubscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'))\n    return false\n  }\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // Unsubs\n  let result = true\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction unsuback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const granted = settings.granted\n  const properties = settings.properties\n  const type = settings.cmd\n  const qos = 0\n\n  let length = 2\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // Check granted\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'))\n          return false\n        }\n        length += 1\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'))\n      return false\n    }\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // payload\n  if (version === 5) {\n    stream.write(Buffer.from(granted))\n  }\n  return true\n}\n\nfunction emptyPacket (packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd])\n}\n\nfunction disconnect (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.disconnect << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return true\n}\n\nfunction auth (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'))\n\n  // properies mqtt 5\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n  if (!propertiesData) { return false }\n  length += propertiesData.length\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.auth << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  stream.write(Buffer.from([reasonCode]))\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nconst varByteIntCache = {}\nfunction writeVarByteInt (stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`))\n    return false\n  }\n\n  let buffer = varByteIntCache[num]\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num)\n    if (num < 16384) varByteIntCache[num] = buffer\n  }\n  debug('writeVarByteInt: writing to stream: %o', buffer)\n  return stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  const strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  debug('writeString: %s', string)\n  return stream.write(string, 'utf8')\n}\n\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeStringPair (stream, name, value) {\n  writeString(stream, name)\n  writeString(stream, value)\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  debug('writeNumberCached: number: %d', number)\n  debug('writeNumberCached: %o', numCache[number])\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  const generatedNumber = generateNumber(number)\n  debug('writeNumberGenerated: %o', generatedNumber)\n  return stream.write(generatedNumber)\n}\nfunction write4ByteNumber (stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number)\n  debug('write4ByteNumber: %o', generated4ByteBuffer)\n  return stream.write(generated4ByteBuffer)\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction getProperties (stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n      write () {\n        writeProperties(stream, {}, 0)\n      }\n    }\n  }\n  let propertiesLength = 0\n  function getLengthProperty (name, value) {\n    const type = protocol.propertiesTypes[name]\n    let length = 0\n    switch (type) {\n      case 'byte': {\n        if (typeof value !== 'boolean') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'int8': {\n        if (typeof value !== 'number' || value < 0 || value > 0xff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'binary': {\n        if (value && value === null) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(value) + 2\n        break\n      }\n      case 'int16': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2\n        break\n      }\n      case 'int32': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 4\n        break\n      }\n      case 'var': {\n        // var byte integer is max 24 bits packed in 32 bits\n        if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(genBufVariableByteInt(value))\n        break\n      }\n      case 'string': {\n        if (typeof value !== 'string') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2 + Buffer.byteLength(value.toString())\n        break\n      }\n      case 'pair': {\n        if (typeof value !== 'object') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n          const currentValue = value[name]\n          if (Array.isArray(currentValue)) {\n            result += currentValue.reduce((currentLength, value) => {\n              currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString())\n              return currentLength\n            }, 0)\n          } else {\n            result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())\n          }\n          return result\n        }, 0)\n        break\n      }\n      default: {\n        stream.emit('error', new Error(`Invalid property ${name}: ${value}`))\n        return false\n      }\n    }\n    return length\n  }\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0\n      let propValueLength = 0\n      const propValue = properties[propName]\n      if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex])\n          if (!propValueLength) { return false }\n          propLength += propValueLength\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue)\n        if (!propValueLength) { return false }\n        propLength = propValueLength\n      }\n      if (!propLength) return false\n      propertiesLength += propLength\n    }\n  }\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength))\n\n  return {\n    length: propertiesLengthLength + propertiesLength,\n    write () {\n      writeProperties(stream, properties, propertiesLength)\n    }\n  }\n}\n\nfunction getPropertiesByMaximumPacketSize (stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties']\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0\n\n  let propertiesData = getProperties(stream, properties)\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift()\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp]\n        propertiesData = getProperties(stream, properties)\n      } else {\n        return false\n      }\n    }\n  }\n  return propertiesData\n}\n\nfunction writeProperty (stream, propName, value) {\n  const type = protocol.propertiesTypes[propName]\n  switch (type) {\n    case 'byte': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([+value]))\n      break\n    }\n    case 'int8': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([value]))\n      break\n    }\n    case 'binary': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeStringOrBuffer(stream, value)\n      break\n    }\n    case 'int16': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeNumber(stream, value)\n      break\n    }\n    case 'int32': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      write4ByteNumber(stream, value)\n      break\n    }\n    case 'var': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeVarByteInt(stream, value)\n      break\n    }\n    case 'string': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeString(stream, value)\n      break\n    }\n    case 'pair': {\n      Object.getOwnPropertyNames(value).forEach(name => {\n        const currentValue = value[name]\n        if (Array.isArray(currentValue)) {\n          currentValue.forEach(value => {\n            stream.write(Buffer.from([protocol.properties[propName]]))\n            writeStringPair(stream, name.toString(), value.toString())\n          })\n        } else {\n          stream.write(Buffer.from([protocol.properties[propName]]))\n          writeStringPair(stream, name.toString(), currentValue.toString())\n        }\n      })\n      break\n    }\n    default: {\n      stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`))\n      return false\n    }\n  }\n}\n\nfunction writeProperties (stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength)\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      const value = properties[propName]\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex])\n        }\n      } else {\n        writeProperty(stream, propName, value)\n      }\n    }\n  }\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n"]},"metadata":{},"sourceType":"script"}