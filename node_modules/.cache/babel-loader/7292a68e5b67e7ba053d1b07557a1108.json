{"ast":null,"code":"var max = 65536;\nvar cache = {}; // in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer\n// later versions return a Buffer\n// alternative is Buffer.slice but that creates a new buffer\n// creating new buffers takes time\n// SubOk is only false on node < 8\n\nvar SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1));\n\nfunction generateBuffer(i) {\n  var buffer = Buffer.allocUnsafe(2);\n  buffer.writeUInt8(i >> 8, 0);\n  buffer.writeUInt8(i & 0x00FF, 0 + 1);\n  return buffer;\n}\n\nfunction generateCache() {\n  for (var i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i);\n  }\n}\n\nfunction genBufVariableByteInt(num) {\n  var maxLength = 4; // max 4 bytes\n\n  var digit = 0;\n  var pos = 0;\n  var buffer = Buffer.allocUnsafe(maxLength);\n\n  do {\n    digit = num % 128 | 0;\n    num = num / 128 | 0;\n    if (num > 0) digit = digit | 0x80;\n    buffer.writeUInt8(digit, pos++);\n  } while (num > 0 && pos < maxLength);\n\n  if (num > 0) {\n    pos = 0;\n  }\n\n  return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos);\n}\n\nfunction generate4ByteBuffer(num) {\n  var buffer = Buffer.allocUnsafe(4);\n  buffer.writeUInt32BE(num, 0);\n  return buffer;\n}\n\nmodule.exports = {\n  cache: cache,\n  generateCache: generateCache,\n  generateNumber: generateBuffer,\n  genBufVariableByteInt: genBufVariableByteInt,\n  generate4ByteBuffer: generate4ByteBuffer\n};","map":{"version":3,"sources":["/home/one/node_modules/mqtt-packet/numbers.js"],"names":["max","cache","SubOk","Buffer","isBuffer","from","subarray","generateBuffer","i","buffer","allocUnsafe","writeUInt8","generateCache","genBufVariableByteInt","num","maxLength","digit","pos","slice","generate4ByteBuffer","writeUInt32BE","module","exports","generateNumber"],"mappings":"AAAA,IAAMA,GAAG,GAAG,KAAZ;AACA,IAAMC,KAAK,GAAG,EAAd,C,CAEA;AACA;AACA;AACA;AACA;;AACA,IAAMC,KAAK,GAAGC,MAAM,CAACC,QAAP,CAAgBD,MAAM,CAACE,IAAP,CAAY,CAAC,CAAD,EAAI,CAAJ,CAAZ,EAAoBC,QAApB,CAA6B,CAA7B,EAAgC,CAAhC,CAAhB,CAAd;;AAEA,SAASC,cAAT,CAAyBC,CAAzB,EAA4B;AAC1B,MAAMC,MAAM,GAAGN,MAAM,CAACO,WAAP,CAAmB,CAAnB,CAAf;AACAD,EAAAA,MAAM,CAACE,UAAP,CAAkBH,CAAC,IAAI,CAAvB,EAA0B,CAA1B;AACAC,EAAAA,MAAM,CAACE,UAAP,CAAkBH,CAAC,GAAG,MAAtB,EAA8B,IAAI,CAAlC;AAEA,SAAOC,MAAP;AACD;;AAED,SAASG,aAAT,GAA0B;AACxB,OAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,GAApB,EAAyBQ,CAAC,EAA1B,EAA8B;AAC5BP,IAAAA,KAAK,CAACO,CAAD,CAAL,GAAWD,cAAc,CAACC,CAAD,CAAzB;AACD;AACF;;AAED,SAASK,qBAAT,CAAgCC,GAAhC,EAAqC;AACnC,MAAMC,SAAS,GAAG,CAAlB,CADmC,CACf;;AACpB,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAG,GAAG,CAAV;AACA,MAAMR,MAAM,GAAGN,MAAM,CAACO,WAAP,CAAmBK,SAAnB,CAAf;;AAEA,KAAG;AACDC,IAAAA,KAAK,GAAGF,GAAG,GAAG,GAAN,GAAY,CAApB;AACAA,IAAAA,GAAG,GAAGA,GAAG,GAAG,GAAN,GAAY,CAAlB;AACA,QAAIA,GAAG,GAAG,CAAV,EAAaE,KAAK,GAAGA,KAAK,GAAG,IAAhB;AAEbP,IAAAA,MAAM,CAACE,UAAP,CAAkBK,KAAlB,EAAyBC,GAAG,EAA5B;AACD,GAND,QAMSH,GAAG,GAAG,CAAN,IAAWG,GAAG,GAAGF,SAN1B;;AAQA,MAAID,GAAG,GAAG,CAAV,EAAa;AACXG,IAAAA,GAAG,GAAG,CAAN;AACD;;AAED,SAAOf,KAAK,GAAGO,MAAM,CAACH,QAAP,CAAgB,CAAhB,EAAmBW,GAAnB,CAAH,GAA6BR,MAAM,CAACS,KAAP,CAAa,CAAb,EAAgBD,GAAhB,CAAzC;AACD;;AAED,SAASE,mBAAT,CAA8BL,GAA9B,EAAmC;AACjC,MAAML,MAAM,GAAGN,MAAM,CAACO,WAAP,CAAmB,CAAnB,CAAf;AACAD,EAAAA,MAAM,CAACW,aAAP,CAAqBN,GAArB,EAA0B,CAA1B;AACA,SAAOL,MAAP;AACD;;AAEDY,MAAM,CAACC,OAAP,GAAiB;AACfrB,EAAAA,KAAK,EAALA,KADe;AAEfW,EAAAA,aAAa,EAAbA,aAFe;AAGfW,EAAAA,cAAc,EAAEhB,cAHD;AAIfM,EAAAA,qBAAqB,EAArBA,qBAJe;AAKfM,EAAAA,mBAAmB,EAAnBA;AALe,CAAjB","sourcesContent":["const max = 65536\nconst cache = {}\n\n// in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer\n// later versions return a Buffer\n// alternative is Buffer.slice but that creates a new buffer\n// creating new buffers takes time\n// SubOk is only false on node < 8\nconst SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1))\n\nfunction generateBuffer (i) {\n  const buffer = Buffer.allocUnsafe(2)\n  buffer.writeUInt8(i >> 8, 0)\n  buffer.writeUInt8(i & 0x00FF, 0 + 1)\n\n  return buffer\n}\n\nfunction generateCache () {\n  for (let i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i)\n  }\n}\n\nfunction genBufVariableByteInt (num) {\n  const maxLength = 4 // max 4 bytes\n  let digit = 0\n  let pos = 0\n  const buffer = Buffer.allocUnsafe(maxLength)\n\n  do {\n    digit = num % 128 | 0\n    num = num / 128 | 0\n    if (num > 0) digit = digit | 0x80\n\n    buffer.writeUInt8(digit, pos++)\n  } while (num > 0 && pos < maxLength)\n\n  if (num > 0) {\n    pos = 0\n  }\n\n  return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos)\n}\n\nfunction generate4ByteBuffer (num) {\n  const buffer = Buffer.allocUnsafe(4)\n  buffer.writeUInt32BE(num, 0)\n  return buffer\n}\n\nmodule.exports = {\n  cache,\n  generateCache,\n  generateNumber: generateBuffer,\n  genBufVariableByteInt,\n  generate4ByteBuffer\n}\n"]},"metadata":{},"sourceType":"script"}