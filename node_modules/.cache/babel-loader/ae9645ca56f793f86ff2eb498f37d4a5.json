{"ast":null,"code":"const writeToStream = require('./writeToStream');\n\nconst EventEmitter = require('events');\n\nfunction generate(packet, opts) {\n  const stream = new Accumulator();\n  writeToStream(packet, stream, opts);\n  return stream.concat();\n}\n\nclass Accumulator extends EventEmitter {\n  constructor() {\n    super();\n    this._array = new Array(20);\n    this._i = 0;\n  }\n\n  write(chunk) {\n    this._array[this._i++] = chunk;\n    return true;\n  }\n\n  concat() {\n    let length = 0;\n    const lengths = new Array(this._array.length);\n    const list = this._array;\n    let pos = 0;\n    let i;\n\n    for (i = 0; i < list.length && list[i] !== undefined; i++) {\n      if (typeof list[i] !== 'string') lengths[i] = list[i].length;else lengths[i] = Buffer.byteLength(list[i]);\n      length += lengths[i];\n    }\n\n    const result = Buffer.allocUnsafe(length);\n\n    for (i = 0; i < list.length && list[i] !== undefined; i++) {\n      if (typeof list[i] !== 'string') {\n        list[i].copy(result, pos);\n        pos += lengths[i];\n      } else {\n        result.write(list[i], pos);\n        pos += lengths[i];\n      }\n    }\n\n    return result;\n  }\n\n}\n\nmodule.exports = generate;","map":{"version":3,"sources":["/home/one/node_modules/mqtt-packet/generate.js"],"names":["writeToStream","require","EventEmitter","generate","packet","opts","stream","Accumulator","concat","constructor","_array","Array","_i","write","chunk","length","lengths","list","pos","i","undefined","Buffer","byteLength","result","allocUnsafe","copy","module","exports"],"mappings":"AAAA,MAAMA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA7B;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,QAAD,CAA5B;;AAEA,SAASE,QAAT,CAAmBC,MAAnB,EAA2BC,IAA3B,EAAiC;AAC/B,QAAMC,MAAM,GAAG,IAAIC,WAAJ,EAAf;AACAP,EAAAA,aAAa,CAACI,MAAD,EAASE,MAAT,EAAiBD,IAAjB,CAAb;AACA,SAAOC,MAAM,CAACE,MAAP,EAAP;AACD;;AAED,MAAMD,WAAN,SAA0BL,YAA1B,CAAuC;AACrCO,EAAAA,WAAW,GAAI;AACb;AACA,SAAKC,MAAL,GAAc,IAAIC,KAAJ,CAAU,EAAV,CAAd;AACA,SAAKC,EAAL,GAAU,CAAV;AACD;;AAEDC,EAAAA,KAAK,CAAEC,KAAF,EAAS;AACZ,SAAKJ,MAAL,CAAY,KAAKE,EAAL,EAAZ,IAAyBE,KAAzB;AACA,WAAO,IAAP;AACD;;AAEDN,EAAAA,MAAM,GAAI;AACR,QAAIO,MAAM,GAAG,CAAb;AACA,UAAMC,OAAO,GAAG,IAAIL,KAAJ,CAAU,KAAKD,MAAL,CAAYK,MAAtB,CAAhB;AACA,UAAME,IAAI,GAAG,KAAKP,MAAlB;AACA,QAAIQ,GAAG,GAAG,CAAV;AACA,QAAIC,CAAJ;;AAEA,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,IAAI,CAACF,MAAT,IAAmBE,IAAI,CAACE,CAAD,CAAJ,KAAYC,SAA3C,EAAsDD,CAAC,EAAvD,EAA2D;AACzD,UAAI,OAAOF,IAAI,CAACE,CAAD,CAAX,KAAmB,QAAvB,EAAiCH,OAAO,CAACG,CAAD,CAAP,GAAaF,IAAI,CAACE,CAAD,CAAJ,CAAQJ,MAArB,CAAjC,KACKC,OAAO,CAACG,CAAD,CAAP,GAAaE,MAAM,CAACC,UAAP,CAAkBL,IAAI,CAACE,CAAD,CAAtB,CAAb;AAELJ,MAAAA,MAAM,IAAIC,OAAO,CAACG,CAAD,CAAjB;AACD;;AAED,UAAMI,MAAM,GAAGF,MAAM,CAACG,WAAP,CAAmBT,MAAnB,CAAf;;AAEA,SAAKI,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,IAAI,CAACF,MAAT,IAAmBE,IAAI,CAACE,CAAD,CAAJ,KAAYC,SAA3C,EAAsDD,CAAC,EAAvD,EAA2D;AACzD,UAAI,OAAOF,IAAI,CAACE,CAAD,CAAX,KAAmB,QAAvB,EAAiC;AAC/BF,QAAAA,IAAI,CAACE,CAAD,CAAJ,CAAQM,IAAR,CAAaF,MAAb,EAAqBL,GAArB;AACAA,QAAAA,GAAG,IAAIF,OAAO,CAACG,CAAD,CAAd;AACD,OAHD,MAGO;AACLI,QAAAA,MAAM,CAACV,KAAP,CAAaI,IAAI,CAACE,CAAD,CAAjB,EAAsBD,GAAtB;AACAA,QAAAA,GAAG,IAAIF,OAAO,CAACG,CAAD,CAAd;AACD;AACF;;AAED,WAAOI,MAAP;AACD;;AAvCoC;;AA0CvCG,MAAM,CAACC,OAAP,GAAiBxB,QAAjB","sourcesContent":["const writeToStream = require('./writeToStream')\nconst EventEmitter = require('events')\n\nfunction generate (packet, opts) {\n  const stream = new Accumulator()\n  writeToStream(packet, stream, opts)\n  return stream.concat()\n}\n\nclass Accumulator extends EventEmitter {\n  constructor () {\n    super()\n    this._array = new Array(20)\n    this._i = 0\n  }\n\n  write (chunk) {\n    this._array[this._i++] = chunk\n    return true\n  }\n\n  concat () {\n    let length = 0\n    const lengths = new Array(this._array.length)\n    const list = this._array\n    let pos = 0\n    let i\n\n    for (i = 0; i < list.length && list[i] !== undefined; i++) {\n      if (typeof list[i] !== 'string') lengths[i] = list[i].length\n      else lengths[i] = Buffer.byteLength(list[i])\n\n      length += lengths[i]\n    }\n\n    const result = Buffer.allocUnsafe(length)\n\n    for (i = 0; i < list.length && list[i] !== undefined; i++) {\n      if (typeof list[i] !== 'string') {\n        list[i].copy(result, pos)\n        pos += lengths[i]\n      } else {\n        result.write(list[i], pos)\n        pos += lengths[i]\n      }\n    }\n\n    return result\n  }\n}\n\nmodule.exports = generate\n"]},"metadata":{},"sourceType":"script"}