{"ast":null,"code":"const bl = require('bl');\n\nconst EventEmitter = require('events');\n\nconst Packet = require('./packet');\n\nconst constants = require('./constants');\n\nconst debug = require('debug')('mqtt-packet:parser');\n\nclass Parser extends EventEmitter {\n  constructor() {\n    super();\n    this.parser = this.constructor.parser;\n  }\n\n  static parser(opt) {\n    if (!(this instanceof Parser)) return new Parser().parser(opt);\n    this.settings = opt || {};\n    this._states = ['_parseHeader', '_parseLength', '_parsePayload', '_newPacket'];\n\n    this._resetState();\n\n    return this;\n  }\n\n  _resetState() {\n    debug('_resetState: resetting packet, error, _list, and _stateCounter');\n    this.packet = new Packet();\n    this.error = null;\n    this._list = bl();\n    this._stateCounter = 0;\n  }\n\n  parse(buf) {\n    if (this.error) this._resetState();\n\n    this._list.append(buf);\n\n    debug('parse: current state: %s', this._states[this._stateCounter]);\n\n    while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {\n      this._stateCounter++;\n      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter);\n      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length);\n      if (this._stateCounter >= this._states.length) this._stateCounter = 0;\n    }\n\n    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length);\n    return this._list.length;\n  }\n\n  _parseHeader() {\n    // There is at least one byte in the buffer\n    const zero = this._list.readUInt8(0);\n\n    this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];\n    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;\n    this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;\n    this.packet.dup = (zero & constants.DUP_MASK) !== 0;\n    debug('_parseHeader: packet: %o', this.packet);\n\n    this._list.consume(1);\n\n    return true;\n  }\n\n  _parseLength() {\n    // There is at least one byte in the list\n    const result = this._parseVarByteNum(true);\n\n    if (result) {\n      this.packet.length = result.value;\n\n      this._list.consume(result.bytes);\n    }\n\n    debug('_parseLength %d', result.value);\n    return !!result;\n  }\n\n  _parsePayload() {\n    debug('_parsePayload: payload %O', this._list);\n    let result = false; // Do we have a payload? Do we have enough data to complete the payload?\n    // PINGs have no payload\n\n    if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n      this._pos = 0;\n\n      switch (this.packet.cmd) {\n        case 'connect':\n          this._parseConnect();\n\n          break;\n\n        case 'connack':\n          this._parseConnack();\n\n          break;\n\n        case 'publish':\n          this._parsePublish();\n\n          break;\n\n        case 'puback':\n        case 'pubrec':\n        case 'pubrel':\n        case 'pubcomp':\n          this._parseConfirmation();\n\n          break;\n\n        case 'subscribe':\n          this._parseSubscribe();\n\n          break;\n\n        case 'suback':\n          this._parseSuback();\n\n          break;\n\n        case 'unsubscribe':\n          this._parseUnsubscribe();\n\n          break;\n\n        case 'unsuback':\n          this._parseUnsuback();\n\n          break;\n\n        case 'pingreq':\n        case 'pingresp':\n          // These are empty, nothing to do\n          break;\n\n        case 'disconnect':\n          this._parseDisconnect();\n\n          break;\n\n        case 'auth':\n          this._parseAuth();\n\n          break;\n\n        default:\n          this._emitError(new Error('Not supported'));\n\n      }\n\n      result = true;\n    }\n\n    debug('_parsePayload complete result: %s', result);\n    return result;\n  }\n\n  _parseConnect() {\n    debug('_parseConnect');\n    let topic; // Will topic\n\n    let payload; // Will payload\n\n    let password; // Password\n\n    let username; // Username\n\n    const flags = {};\n    const packet = this.packet; // Parse protocolId\n\n    const protocolId = this._parseString();\n\n    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'));\n\n    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n      return this._emitError(new Error('Invalid protocolId'));\n    }\n\n    packet.protocolId = protocolId; // Parse constants version number\n\n    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'));\n    packet.protocolVersion = this._list.readUInt8(this._pos);\n\n    if (packet.protocolVersion >= 128) {\n      packet.bridgeMode = true;\n      packet.protocolVersion = packet.protocolVersion - 128;\n    }\n\n    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n      return this._emitError(new Error('Invalid protocol version'));\n    }\n\n    this._pos++;\n\n    if (this._pos >= this._list.length) {\n      return this._emitError(new Error('Packet too short'));\n    } // Parse connect flags\n\n\n    flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;\n    flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;\n    flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;\n\n    if (flags.will) {\n      packet.will = {};\n      packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;\n      packet.will.qos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;\n    }\n\n    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;\n    this._pos++; // Parse keepalive\n\n    packet.keepalive = this._parseNum();\n    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short')); // parse properties\n\n    if (packet.protocolVersion === 5) {\n      const properties = this._parseProperties();\n\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    } // Parse clientId\n\n\n    const clientId = this._parseString();\n\n    if (clientId === null) return this._emitError(new Error('Packet too short'));\n    packet.clientId = clientId;\n    debug('_parseConnect: packet.clientId: %s', packet.clientId);\n\n    if (flags.will) {\n      if (packet.protocolVersion === 5) {\n        const willProperties = this._parseProperties();\n\n        if (Object.getOwnPropertyNames(willProperties).length) {\n          packet.will.properties = willProperties;\n        }\n      } // Parse will topic\n\n\n      topic = this._parseString();\n      if (topic === null) return this._emitError(new Error('Cannot parse will topic'));\n      packet.will.topic = topic;\n      debug('_parseConnect: packet.will.topic: %s', packet.will.topic); // Parse will payload\n\n      payload = this._parseBuffer();\n      if (payload === null) return this._emitError(new Error('Cannot parse will payload'));\n      packet.will.payload = payload;\n      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload);\n    } // Parse username\n\n\n    if (flags.username) {\n      username = this._parseString();\n      if (username === null) return this._emitError(new Error('Cannot parse username'));\n      packet.username = username;\n      debug('_parseConnect: packet.username: %s', packet.username);\n    } // Parse password\n\n\n    if (flags.password) {\n      password = this._parseBuffer();\n      if (password === null) return this._emitError(new Error('Cannot parse password'));\n      packet.password = password;\n    } // need for right parse auth packet and self set up\n\n\n    this.settings = packet;\n    debug('_parseConnect: complete');\n    return packet;\n  }\n\n  _parseConnack() {\n    debug('_parseConnack');\n    const packet = this.packet;\n    if (this._list.length < 1) return null;\n    packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);\n\n    if (this.settings.protocolVersion === 5) {\n      if (this._list.length >= 2) {\n        packet.reasonCode = this._list.readUInt8(this._pos++);\n      } else {\n        packet.reasonCode = 0;\n      }\n    } else {\n      if (this._list.length < 2) return null;\n      packet.returnCode = this._list.readUInt8(this._pos++);\n    }\n\n    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code')); // mqtt 5 properties\n\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n\n    debug('_parseConnack: complete');\n  }\n\n  _parsePublish() {\n    debug('_parsePublish');\n    const packet = this.packet;\n    packet.topic = this._parseString();\n    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic')); // Parse messageId\n\n    if (packet.qos > 0) if (!this._parseMessageId()) {\n      return;\n    } // Properties mqtt 5\n\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n\n    packet.payload = this._list.slice(this._pos, packet.length);\n    debug('_parsePublish: payload from buffer list: %o', packet.payload);\n  }\n\n  _parseSubscribe() {\n    debug('_parseSubscribe');\n    const packet = this.packet;\n    let topic;\n    let options;\n    let qos;\n    let rh;\n    let rap;\n    let nl;\n    let subscription;\n\n    if (packet.qos !== 1) {\n      return this._emitError(new Error('Wrong subscribe header'));\n    }\n\n    packet.subscriptions = [];\n\n    if (!this._parseMessageId()) {\n      return;\n    } // Properties mqtt 5\n\n\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      topic = this._parseString();\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'));\n      options = this._parseByte();\n      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;\n      nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;\n      rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;\n      rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;\n      subscription = {\n        topic,\n        qos\n      }; // mqtt 5 options\n\n      if (this.settings.protocolVersion === 5) {\n        subscription.nl = nl;\n        subscription.rap = rap;\n        subscription.rh = rh;\n      } else if (this.settings.bridgeMode) {\n        subscription.rh = 0;\n        subscription.rap = true;\n        subscription.nl = true;\n      } // Push pair to subscriptions\n\n\n      debug('_parseSubscribe: push subscription `%s` to subscription', subscription);\n      packet.subscriptions.push(subscription);\n    }\n  }\n\n  _parseSuback() {\n    debug('_parseSuback');\n    const packet = this.packet;\n    this.packet.granted = [];\n\n    if (!this._parseMessageId()) {\n      return;\n    } // Properties mqtt 5\n\n\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    } // Parse granted QoSes\n\n\n    while (this._pos < this.packet.length) {\n      this.packet.granted.push(this._list.readUInt8(this._pos++));\n    }\n  }\n\n  _parseUnsubscribe() {\n    debug('_parseUnsubscribe');\n    const packet = this.packet;\n    packet.unsubscriptions = []; // Parse messageId\n\n    if (!this._parseMessageId()) {\n      return;\n    } // Properties mqtt 5\n\n\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      const topic = this._parseString();\n\n      if (topic === null) return this._emitError(new Error('Cannot parse topic')); // Push topic to unsubscriptions\n\n      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic);\n      packet.unsubscriptions.push(topic);\n    }\n  }\n\n  _parseUnsuback() {\n    debug('_parseUnsuback');\n    const packet = this.packet;\n    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId')); // Properties mqtt 5\n\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties();\n\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      } // Parse granted QoSes\n\n\n      packet.granted = [];\n\n      while (this._pos < this.packet.length) {\n        this.packet.granted.push(this._list.readUInt8(this._pos++));\n      }\n    }\n  } // parse packets like puback, pubrec, pubrel, pubcomp\n\n\n  _parseConfirmation() {\n    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd);\n    const packet = this.packet;\n\n    this._parseMessageId();\n\n    if (this.settings.protocolVersion === 5) {\n      if (packet.length > 2) {\n        // response code\n        packet.reasonCode = this._parseByte();\n        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode);\n      } else {\n        packet.reasonCode = 0;\n      }\n\n      if (packet.length > 3) {\n        // properies mqtt 5\n        const properties = this._parseProperties();\n\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties;\n        }\n      }\n    }\n\n    return true;\n  } // parse disconnect packet\n\n\n  _parseDisconnect() {\n    const packet = this.packet;\n    debug('_parseDisconnect');\n\n    if (this.settings.protocolVersion === 5) {\n      // response code\n      if (this._list.length > 0) {\n        packet.reasonCode = this._parseByte();\n      } else {\n        packet.reasonCode = 0;\n      } // properies mqtt 5\n\n\n      const properties = this._parseProperties();\n\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties;\n      }\n    }\n\n    debug('_parseDisconnect result: true');\n    return true;\n  } // parse auth packet\n\n\n  _parseAuth() {\n    debug('_parseAuth');\n    const packet = this.packet;\n\n    if (this.settings.protocolVersion !== 5) {\n      return this._emitError(new Error('Not supported auth packet for this version MQTT'));\n    } // response code\n\n\n    packet.reasonCode = this._parseByte(); // properies mqtt 5\n\n    const properties = this._parseProperties();\n\n    if (Object.getOwnPropertyNames(properties).length) {\n      packet.properties = properties;\n    }\n\n    debug('_parseAuth: result: true');\n    return true;\n  }\n\n  _parseMessageId() {\n    const packet = this.packet;\n    packet.messageId = this._parseNum();\n\n    if (packet.messageId === null) {\n      this._emitError(new Error('Cannot parse messageId'));\n\n      return false;\n    }\n\n    debug('_parseMessageId: packet.messageId %d', packet.messageId);\n    return true;\n  }\n\n  _parseString(maybeBuffer) {\n    const length = this._parseNum();\n\n    const end = length + this._pos;\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n    const result = this._list.toString('utf8', this._pos, end);\n\n    this._pos += length;\n    debug('_parseString: result: %s', result);\n    return result;\n  }\n\n  _parseStringPair() {\n    debug('_parseStringPair');\n    return {\n      name: this._parseString(),\n      value: this._parseString()\n    };\n  }\n\n  _parseBuffer() {\n    const length = this._parseNum();\n\n    const end = length + this._pos;\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n    const result = this._list.slice(this._pos, end);\n\n    this._pos += length;\n    debug('_parseBuffer: result: %o', result);\n    return result;\n  }\n\n  _parseNum() {\n    if (this._list.length - this._pos < 2) return -1;\n\n    const result = this._list.readUInt16BE(this._pos);\n\n    this._pos += 2;\n    debug('_parseNum: result: %s', result);\n    return result;\n  }\n\n  _parse4ByteNum() {\n    if (this._list.length - this._pos < 4) return -1;\n\n    const result = this._list.readUInt32BE(this._pos);\n\n    this._pos += 4;\n    debug('_parse4ByteNum: result: %s', result);\n    return result;\n  }\n\n  _parseVarByteNum(fullInfoFlag) {\n    debug('_parseVarByteNum');\n    const maxBytes = 4;\n    let bytes = 0;\n    let mul = 1;\n    let value = 0;\n    let result = false;\n    let current;\n    const padding = this._pos ? this._pos : 0;\n\n    while (bytes < maxBytes && padding + bytes < this._list.length) {\n      current = this._list.readUInt8(padding + bytes++);\n      value += mul * (current & constants.VARBYTEINT_MASK);\n      mul *= 0x80;\n\n      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n        result = true;\n        break;\n      }\n\n      if (this._list.length <= bytes) {\n        break;\n      }\n    }\n\n    if (!result && bytes === maxBytes && this._list.length >= bytes) {\n      this._emitError(new Error('Invalid variable byte integer'));\n    }\n\n    if (padding) {\n      this._pos += bytes;\n    }\n\n    result = result ? fullInfoFlag ? {\n      bytes,\n      value\n    } : value : false;\n    debug('_parseVarByteNum: result: %o', result);\n    return result;\n  }\n\n  _parseByte() {\n    const result = this._list.readUInt8(this._pos);\n\n    this._pos++;\n    debug('_parseByte: result: %o', result);\n    return result;\n  }\n\n  _parseByType(type) {\n    debug('_parseByType: type: %s', type);\n\n    switch (type) {\n      case 'byte':\n        {\n          return this._parseByte() !== 0;\n        }\n\n      case 'int8':\n        {\n          return this._parseByte();\n        }\n\n      case 'int16':\n        {\n          return this._parseNum();\n        }\n\n      case 'int32':\n        {\n          return this._parse4ByteNum();\n        }\n\n      case 'var':\n        {\n          return this._parseVarByteNum();\n        }\n\n      case 'string':\n        {\n          return this._parseString();\n        }\n\n      case 'pair':\n        {\n          return this._parseStringPair();\n        }\n\n      case 'binary':\n        {\n          return this._parseBuffer();\n        }\n    }\n  }\n\n  _parseProperties() {\n    debug('_parseProperties');\n\n    const length = this._parseVarByteNum();\n\n    const start = this._pos;\n    const end = start + length;\n    const result = {};\n\n    while (this._pos < end) {\n      const type = this._parseByte();\n\n      const name = constants.propertiesCodes[type];\n\n      if (!name) {\n        this._emitError(new Error('Unknown property'));\n\n        return false;\n      } // user properties process\n\n\n      if (name === 'userProperties') {\n        if (!result[name]) {\n          result[name] = Object.create(null);\n        }\n\n        const currentUserProperty = this._parseByType(constants.propertiesTypes[name]);\n\n        if (result[name][currentUserProperty.name]) {\n          if (Array.isArray(result[name][currentUserProperty.name])) {\n            result[name][currentUserProperty.name].push(currentUserProperty.value);\n          } else {\n            const currentValue = result[name][currentUserProperty.name];\n            result[name][currentUserProperty.name] = [currentValue];\n            result[name][currentUserProperty.name].push(currentUserProperty.value);\n          }\n        } else {\n          result[name][currentUserProperty.name] = currentUserProperty.value;\n        }\n\n        continue;\n      }\n\n      if (result[name]) {\n        if (Array.isArray(result[name])) {\n          result[name].push(this._parseByType(constants.propertiesTypes[name]));\n        } else {\n          result[name] = [result[name]];\n          result[name].push(this._parseByType(constants.propertiesTypes[name]));\n        }\n      } else {\n        result[name] = this._parseByType(constants.propertiesTypes[name]);\n      }\n    }\n\n    return result;\n  }\n\n  _newPacket() {\n    debug('_newPacket');\n\n    if (this.packet) {\n      this._list.consume(this.packet.length);\n\n      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length);\n      this.emit('packet', this.packet);\n    }\n\n    debug('_newPacket: new packet');\n    this.packet = new Packet();\n    this._pos = 0;\n    return true;\n  }\n\n  _emitError(err) {\n    debug('_emitError');\n    this.error = err;\n    this.emit('error', err);\n  }\n\n}\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/home/one/node_modules/mqtt-packet/parser.js"],"names":["bl","require","EventEmitter","Packet","constants","debug","Parser","constructor","parser","opt","settings","_states","_resetState","packet","error","_list","_stateCounter","parse","buf","append","length","_parseHeader","zero","readUInt8","cmd","types","CMD_SHIFT","retain","RETAIN_MASK","qos","QOS_SHIFT","QOS_MASK","dup","DUP_MASK","consume","_parseLength","result","_parseVarByteNum","value","bytes","_parsePayload","_pos","_parseConnect","_parseConnack","_parsePublish","_parseConfirmation","_parseSubscribe","_parseSuback","_parseUnsubscribe","_parseUnsuback","_parseDisconnect","_parseAuth","_emitError","Error","topic","payload","password","username","flags","protocolId","_parseString","protocolVersion","bridgeMode","USERNAME_MASK","PASSWORD_MASK","will","WILL_FLAG_MASK","WILL_RETAIN_MASK","WILL_QOS_MASK","WILL_QOS_SHIFT","clean","CLEAN_SESSION_MASK","keepalive","_parseNum","properties","_parseProperties","Object","getOwnPropertyNames","clientId","willProperties","_parseBuffer","sessionPresent","SESSIONPRESENT_MASK","reasonCode","returnCode","_parseMessageId","slice","options","rh","rap","nl","subscription","subscriptions","_parseByte","SUBSCRIBE_OPTIONS_QOS_MASK","SUBSCRIBE_OPTIONS_NL_SHIFT","SUBSCRIBE_OPTIONS_NL_MASK","SUBSCRIBE_OPTIONS_RAP_SHIFT","SUBSCRIBE_OPTIONS_RAP_MASK","SUBSCRIBE_OPTIONS_RH_SHIFT","SUBSCRIBE_OPTIONS_RH_MASK","push","granted","unsubscriptions","messageId","maybeBuffer","end","toString","_parseStringPair","name","readUInt16BE","_parse4ByteNum","readUInt32BE","fullInfoFlag","maxBytes","mul","current","padding","VARBYTEINT_MASK","VARBYTEINT_FIN_MASK","_parseByType","type","start","propertiesCodes","create","currentUserProperty","propertiesTypes","Array","isArray","currentValue","_newPacket","emit","err","module","exports"],"mappings":"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","sourcesContent":["const bl = require('bl')\nconst EventEmitter = require('events')\nconst Packet = require('./packet')\nconst constants = require('./constants')\nconst debug = require('debug')('mqtt-packet:parser')\n\nclass Parser extends EventEmitter {\n  constructor () {\n    super()\n    this.parser = this.constructor.parser\n  }\n\n  static parser (opt) {\n    if (!(this instanceof Parser)) return (new Parser()).parser(opt)\n\n    this.settings = opt || {}\n\n    this._states = [\n      '_parseHeader',\n      '_parseLength',\n      '_parsePayload',\n      '_newPacket'\n    ]\n\n    this._resetState()\n    return this\n  }\n\n  _resetState () {\n    debug('_resetState: resetting packet, error, _list, and _stateCounter')\n    this.packet = new Packet()\n    this.error = null\n    this._list = bl()\n    this._stateCounter = 0\n  }\n\n  parse (buf) {\n    if (this.error) this._resetState()\n\n    this._list.append(buf)\n    debug('parse: current state: %s', this._states[this._stateCounter])\n    while ((this.packet.length !== -1 || this._list.length > 0) &&\n      this[this._states[this._stateCounter]]() &&\n      !this.error) {\n      this._stateCounter++\n      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter)\n      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length)\n      if (this._stateCounter >= this._states.length) this._stateCounter = 0\n    }\n    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length)\n    return this._list.length\n  }\n\n  _parseHeader () {\n    // There is at least one byte in the buffer\n    const zero = this._list.readUInt8(0)\n    this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]\n    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0\n    this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK\n    this.packet.dup = (zero & constants.DUP_MASK) !== 0\n    debug('_parseHeader: packet: %o', this.packet)\n\n    this._list.consume(1)\n\n    return true\n  }\n\n  _parseLength () {\n    // There is at least one byte in the list\n    const result = this._parseVarByteNum(true)\n\n    if (result) {\n      this.packet.length = result.value\n      this._list.consume(result.bytes)\n    }\n    debug('_parseLength %d', result.value)\n    return !!result\n  }\n\n  _parsePayload () {\n    debug('_parsePayload: payload %O', this._list)\n    let result = false\n\n    // Do we have a payload? Do we have enough data to complete the payload?\n    // PINGs have no payload\n    if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n      this._pos = 0\n\n      switch (this.packet.cmd) {\n        case 'connect':\n          this._parseConnect()\n          break\n        case 'connack':\n          this._parseConnack()\n          break\n        case 'publish':\n          this._parsePublish()\n          break\n        case 'puback':\n        case 'pubrec':\n        case 'pubrel':\n        case 'pubcomp':\n          this._parseConfirmation()\n          break\n        case 'subscribe':\n          this._parseSubscribe()\n          break\n        case 'suback':\n          this._parseSuback()\n          break\n        case 'unsubscribe':\n          this._parseUnsubscribe()\n          break\n        case 'unsuback':\n          this._parseUnsuback()\n          break\n        case 'pingreq':\n        case 'pingresp':\n          // These are empty, nothing to do\n          break\n        case 'disconnect':\n          this._parseDisconnect()\n          break\n        case 'auth':\n          this._parseAuth()\n          break\n        default:\n          this._emitError(new Error('Not supported'))\n      }\n\n      result = true\n    }\n    debug('_parsePayload complete result: %s', result)\n    return result\n  }\n\n  _parseConnect () {\n    debug('_parseConnect')\n    let topic // Will topic\n    let payload // Will payload\n    let password // Password\n    let username // Username\n    const flags = {}\n    const packet = this.packet\n\n    // Parse protocolId\n    const protocolId = this._parseString()\n\n    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))\n    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n      return this._emitError(new Error('Invalid protocolId'))\n    }\n\n    packet.protocolId = protocolId\n\n    // Parse constants version number\n    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))\n\n    packet.protocolVersion = this._list.readUInt8(this._pos)\n\n    if (packet.protocolVersion >= 128) {\n      packet.bridgeMode = true\n      packet.protocolVersion = packet.protocolVersion - 128\n    }\n\n    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n      return this._emitError(new Error('Invalid protocol version'))\n    }\n\n    this._pos++\n\n    if (this._pos >= this._list.length) {\n      return this._emitError(new Error('Packet too short'))\n    }\n\n    // Parse connect flags\n    flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)\n    flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)\n    flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)\n\n    if (flags.will) {\n      packet.will = {}\n      packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0\n      packet.will.qos = (this._list.readUInt8(this._pos) &\n        constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT\n    }\n\n    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0\n    this._pos++\n\n    // Parse keepalive\n    packet.keepalive = this._parseNum()\n    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))\n\n    // parse properties\n    if (packet.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    // Parse clientId\n    const clientId = this._parseString()\n    if (clientId === null) return this._emitError(new Error('Packet too short'))\n    packet.clientId = clientId\n    debug('_parseConnect: packet.clientId: %s', packet.clientId)\n\n    if (flags.will) {\n      if (packet.protocolVersion === 5) {\n        const willProperties = this._parseProperties()\n        if (Object.getOwnPropertyNames(willProperties).length) {\n          packet.will.properties = willProperties\n        }\n      }\n      // Parse will topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse will topic'))\n      packet.will.topic = topic\n      debug('_parseConnect: packet.will.topic: %s', packet.will.topic)\n\n      // Parse will payload\n      payload = this._parseBuffer()\n      if (payload === null) return this._emitError(new Error('Cannot parse will payload'))\n      packet.will.payload = payload\n      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload)\n    }\n\n    // Parse username\n    if (flags.username) {\n      username = this._parseString()\n      if (username === null) return this._emitError(new Error('Cannot parse username'))\n      packet.username = username\n      debug('_parseConnect: packet.username: %s', packet.username)\n    }\n\n    // Parse password\n    if (flags.password) {\n      password = this._parseBuffer()\n      if (password === null) return this._emitError(new Error('Cannot parse password'))\n      packet.password = password\n    }\n    // need for right parse auth packet and self set up\n    this.settings = packet\n    debug('_parseConnect: complete')\n    return packet\n  }\n\n  _parseConnack () {\n    debug('_parseConnack')\n    const packet = this.packet\n\n    if (this._list.length < 1) return null\n    packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)\n\n    if (this.settings.protocolVersion === 5) {\n      if (this._list.length >= 2) {\n        packet.reasonCode = this._list.readUInt8(this._pos++)\n      } else {\n        packet.reasonCode = 0\n      }\n    } else {\n      if (this._list.length < 2) return null\n      packet.returnCode = this._list.readUInt8(this._pos++)\n    }\n\n    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'))\n    // mqtt 5 properties\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    debug('_parseConnack: complete')\n  }\n\n  _parsePublish () {\n    debug('_parsePublish')\n    const packet = this.packet\n    packet.topic = this._parseString()\n\n    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    // Parse messageId\n    if (packet.qos > 0) if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    packet.payload = this._list.slice(this._pos, packet.length)\n    debug('_parsePublish: payload from buffer list: %o', packet.payload)\n  }\n\n  _parseSubscribe () {\n    debug('_parseSubscribe')\n    const packet = this.packet\n    let topic\n    let options\n    let qos\n    let rh\n    let rap\n    let nl\n    let subscription\n\n    if (packet.qos !== 1) {\n      return this._emitError(new Error('Wrong subscribe header'))\n    }\n\n    packet.subscriptions = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))\n\n      options = this._parseByte()\n      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK\n      nl = ((options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT) & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0\n      rap = ((options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT) & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0\n      rh = (options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT) & constants.SUBSCRIBE_OPTIONS_RH_MASK\n\n      subscription = { topic, qos }\n\n      // mqtt 5 options\n      if (this.settings.protocolVersion === 5) {\n        subscription.nl = nl\n        subscription.rap = rap\n        subscription.rh = rh\n      } else if (this.settings.bridgeMode) {\n        subscription.rh = 0\n        subscription.rap = true\n        subscription.nl = true\n      }\n\n      // Push pair to subscriptions\n      debug('_parseSubscribe: push subscription `%s` to subscription', subscription)\n      packet.subscriptions.push(subscription)\n    }\n  }\n\n  _parseSuback () {\n    debug('_parseSuback')\n    const packet = this.packet\n    this.packet.granted = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    // Parse granted QoSes\n    while (this._pos < this.packet.length) {\n      this.packet.granted.push(this._list.readUInt8(this._pos++))\n    }\n  }\n\n  _parseUnsubscribe () {\n    debug('_parseUnsubscribe')\n    const packet = this.packet\n\n    packet.unsubscriptions = []\n\n    // Parse messageId\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      const topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n      // Push topic to unsubscriptions\n      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic)\n      packet.unsubscriptions.push(topic)\n    }\n  }\n\n  _parseUnsuback () {\n    debug('_parseUnsuback')\n    const packet = this.packet\n    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n      // Parse granted QoSes\n      packet.granted = []\n      while (this._pos < this.packet.length) {\n        this.packet.granted.push(this._list.readUInt8(this._pos++))\n      }\n    }\n  }\n\n  // parse packets like puback, pubrec, pubrel, pubcomp\n  _parseConfirmation () {\n    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd)\n    const packet = this.packet\n\n    this._parseMessageId()\n\n    if (this.settings.protocolVersion === 5) {\n      if (packet.length > 2) {\n        // response code\n        packet.reasonCode = this._parseByte()\n        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode)\n      } else {\n        packet.reasonCode = 0\n      }\n\n      if (packet.length > 3) {\n        // properies mqtt 5\n        const properties = this._parseProperties()\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties\n        }\n      }\n    }\n\n    return true\n  }\n\n  // parse disconnect packet\n  _parseDisconnect () {\n    const packet = this.packet\n    debug('_parseDisconnect')\n\n    if (this.settings.protocolVersion === 5) {\n      // response code\n      if (this._list.length > 0) {\n        packet.reasonCode = this._parseByte()\n      } else {\n        packet.reasonCode = 0\n      }\n      // properies mqtt 5\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    debug('_parseDisconnect result: true')\n    return true\n  }\n\n  // parse auth packet\n  _parseAuth () {\n    debug('_parseAuth')\n    const packet = this.packet\n\n    if (this.settings.protocolVersion !== 5) {\n      return this._emitError(new Error('Not supported auth packet for this version MQTT'))\n    }\n\n    // response code\n    packet.reasonCode = this._parseByte()\n    // properies mqtt 5\n    const properties = this._parseProperties()\n    if (Object.getOwnPropertyNames(properties).length) {\n      packet.properties = properties\n    }\n\n    debug('_parseAuth: result: true')\n    return true\n  }\n\n  _parseMessageId () {\n    const packet = this.packet\n\n    packet.messageId = this._parseNum()\n\n    if (packet.messageId === null) {\n      this._emitError(new Error('Cannot parse messageId'))\n      return false\n    }\n\n    debug('_parseMessageId: packet.messageId %d', packet.messageId)\n    return true\n  }\n\n  _parseString (maybeBuffer) {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.toString('utf8', this._pos, end)\n    this._pos += length\n    debug('_parseString: result: %s', result)\n    return result\n  }\n\n  _parseStringPair () {\n    debug('_parseStringPair')\n    return {\n      name: this._parseString(),\n      value: this._parseString()\n    }\n  }\n\n  _parseBuffer () {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.slice(this._pos, end)\n\n    this._pos += length\n    debug('_parseBuffer: result: %o', result)\n    return result\n  }\n\n  _parseNum () {\n    if (this._list.length - this._pos < 2) return -1\n\n    const result = this._list.readUInt16BE(this._pos)\n    this._pos += 2\n    debug('_parseNum: result: %s', result)\n    return result\n  }\n\n  _parse4ByteNum () {\n    if (this._list.length - this._pos < 4) return -1\n\n    const result = this._list.readUInt32BE(this._pos)\n    this._pos += 4\n    debug('_parse4ByteNum: result: %s', result)\n    return result\n  }\n\n  _parseVarByteNum (fullInfoFlag) {\n    debug('_parseVarByteNum')\n    const maxBytes = 4\n    let bytes = 0\n    let mul = 1\n    let value = 0\n    let result = false\n    let current\n    const padding = this._pos ? this._pos : 0\n\n    while (bytes < maxBytes && (padding + bytes) < this._list.length) {\n      current = this._list.readUInt8(padding + bytes++)\n      value += mul * (current & constants.VARBYTEINT_MASK)\n      mul *= 0x80\n\n      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n        result = true\n        break\n      }\n      if (this._list.length <= bytes) {\n        break\n      }\n    }\n\n    if (!result && bytes === maxBytes && this._list.length >= bytes) {\n      this._emitError(new Error('Invalid variable byte integer'))\n    }\n\n    if (padding) {\n      this._pos += bytes\n    }\n\n    result = result\n      ? fullInfoFlag ? {\n        bytes,\n        value\n      } : value\n      : false\n\n    debug('_parseVarByteNum: result: %o', result)\n    return result\n  }\n\n  _parseByte () {\n    const result = this._list.readUInt8(this._pos)\n    this._pos++\n    debug('_parseByte: result: %o', result)\n    return result\n  }\n\n  _parseByType (type) {\n    debug('_parseByType: type: %s', type)\n    switch (type) {\n      case 'byte': {\n        return this._parseByte() !== 0\n      }\n      case 'int8': {\n        return this._parseByte()\n      }\n      case 'int16': {\n        return this._parseNum()\n      }\n      case 'int32': {\n        return this._parse4ByteNum()\n      }\n      case 'var': {\n        return this._parseVarByteNum()\n      }\n      case 'string': {\n        return this._parseString()\n      }\n      case 'pair': {\n        return this._parseStringPair()\n      }\n      case 'binary': {\n        return this._parseBuffer()\n      }\n    }\n  }\n\n  _parseProperties () {\n    debug('_parseProperties')\n    const length = this._parseVarByteNum()\n    const start = this._pos\n    const end = start + length\n    const result = {}\n    while (this._pos < end) {\n      const type = this._parseByte()\n      const name = constants.propertiesCodes[type]\n      if (!name) {\n        this._emitError(new Error('Unknown property'))\n        return false\n      }\n      // user properties process\n      if (name === 'userProperties') {\n        if (!result[name]) {\n          result[name] = Object.create(null)\n        }\n        const currentUserProperty = this._parseByType(constants.propertiesTypes[name])\n        if (result[name][currentUserProperty.name]) {\n          if (Array.isArray(result[name][currentUserProperty.name])) {\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          } else {\n            const currentValue = result[name][currentUserProperty.name]\n            result[name][currentUserProperty.name] = [currentValue]\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          }\n        } else {\n          result[name][currentUserProperty.name] = currentUserProperty.value\n        }\n        continue\n      }\n      if (result[name]) {\n        if (Array.isArray(result[name])) {\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        } else {\n          result[name] = [result[name]]\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        }\n      } else {\n        result[name] = this._parseByType(constants.propertiesTypes[name])\n      }\n    }\n    return result\n  }\n\n  _newPacket () {\n    debug('_newPacket')\n    if (this.packet) {\n      this._list.consume(this.packet.length)\n      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length)\n      this.emit('packet', this.packet)\n    }\n    debug('_newPacket: new packet')\n    this.packet = new Packet()\n\n    this._pos = 0\n\n    return true\n  }\n\n  _emitError (err) {\n    debug('_emitError')\n    this.error = err\n    this.emit('error', err)\n  }\n}\n\nmodule.exports = Parser\n"]},"metadata":{},"sourceType":"script"}