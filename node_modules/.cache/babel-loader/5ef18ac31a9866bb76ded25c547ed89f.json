{"ast":null,"code":"'use strict';\n\nvar MqttClient = require('../client');\n\nvar Store = require('../store');\n\nvar url = require('url');\n\nvar xtend = require('xtend');\n\nvar debug = require('debug')('mqttjs');\n\nvar protocols = {}; // eslint-disable-next-line camelcase\n\nif (typeof process !== 'undefined' && process.title !== 'browser' || typeof __webpack_require__ !== 'function') {\n  protocols.mqtt = require('./tcp');\n  protocols.tcp = require('./tcp');\n  protocols.ssl = require('./tls');\n  protocols.tls = require('./tls');\n  protocols.mqtts = require('./tls');\n} else {\n  protocols.wx = require('./wx');\n  protocols.wxs = require('./wx');\n  protocols.ali = require('./ali');\n  protocols.alis = require('./ali');\n}\n\nprotocols.ws = require('./ws');\nprotocols.wss = require('./ws');\n/**\n * Parse the auth attribute and merge username and password in the options object.\n *\n * @param {Object} [opts] option object\n */\n\nfunction parseAuthOptions(opts) {\n  var matches;\n\n  if (opts.auth) {\n    matches = opts.auth.match(/^(.+):(.+)$/);\n\n    if (matches) {\n      opts.username = matches[1];\n      opts.password = matches[2];\n    } else {\n      opts.username = opts.auth;\n    }\n  }\n}\n/**\n * connect - connect to an MQTT broker.\n *\n * @param {String} [brokerUrl] - url of the broker, optional\n * @param {Object} opts - see MqttClient#constructor\n */\n\n\nfunction connect(brokerUrl, opts) {\n  debug('connecting to an MQTT broker...');\n\n  if (typeof brokerUrl === 'object' && !opts) {\n    opts = brokerUrl;\n    brokerUrl = null;\n  }\n\n  opts = opts || {};\n\n  if (brokerUrl) {\n    var parsed = url.parse(brokerUrl, true);\n\n    if (parsed.port != null) {\n      parsed.port = Number(parsed.port);\n    }\n\n    opts = xtend(parsed, opts);\n\n    if (opts.protocol === null) {\n      throw new Error('Missing protocol');\n    }\n\n    opts.protocol = opts.protocol.replace(/:$/, '');\n  } // merge in the auth options if supplied\n\n\n  parseAuthOptions(opts); // support clientId passed in the query string of the url\n\n  if (opts.query && typeof opts.query.clientId === 'string') {\n    opts.clientId = opts.query.clientId;\n  }\n\n  if (opts.cert && opts.key) {\n    if (opts.protocol) {\n      if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n        switch (opts.protocol) {\n          case 'mqtt':\n            opts.protocol = 'mqtts';\n            break;\n\n          case 'ws':\n            opts.protocol = 'wss';\n            break;\n\n          case 'wx':\n            opts.protocol = 'wxs';\n            break;\n\n          case 'ali':\n            opts.protocol = 'alis';\n            break;\n\n          default:\n            throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!');\n        }\n      }\n    } else {\n      // A cert and key was provided, however no protocol was specified, so we will throw an error.\n      throw new Error('Missing secure protocol key');\n    }\n  }\n\n  if (!protocols[opts.protocol]) {\n    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;\n    opts.protocol = ['mqtt', 'mqtts', 'ws', 'wss', 'wx', 'wxs', 'ali', 'alis'].filter(function (key, index) {\n      if (isSecure && index % 2 === 0) {\n        // Skip insecure protocols when requesting a secure one.\n        return false;\n      }\n\n      return typeof protocols[key] === 'function';\n    })[0];\n  }\n\n  if (opts.clean === false && !opts.clientId) {\n    throw new Error('Missing clientId for unclean clients');\n  }\n\n  if (opts.protocol) {\n    opts.defaultProtocol = opts.protocol;\n  }\n\n  function wrapper(client) {\n    if (opts.servers) {\n      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n        client._reconnectCount = 0;\n      }\n\n      opts.host = opts.servers[client._reconnectCount].host;\n      opts.port = opts.servers[client._reconnectCount].port;\n      opts.protocol = !opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol;\n      opts.hostname = opts.host;\n      client._reconnectCount++;\n    }\n\n    debug('calling streambuilder for', opts.protocol);\n    return protocols[opts.protocol](client, opts);\n  }\n\n  var client = new MqttClient(wrapper, opts);\n  client.on('error', function () {\n    /* Automatically set up client error handling */\n  });\n  return client;\n}\n\nmodule.exports = connect;\nmodule.exports.connect = connect;\nmodule.exports.MqttClient = MqttClient;\nmodule.exports.Store = Store;","map":{"version":3,"sources":["/home/one/node_modules/mqtt/lib/connect/index.js"],"names":["MqttClient","require","Store","url","xtend","debug","protocols","process","title","__webpack_require__","mqtt","tcp","ssl","tls","mqtts","wx","wxs","ali","alis","ws","wss","parseAuthOptions","opts","matches","auth","match","username","password","connect","brokerUrl","parsed","parse","port","Number","protocol","Error","replace","query","clientId","cert","key","indexOf","isSecure","filter","index","clean","defaultProtocol","wrapper","client","servers","_reconnectCount","length","host","hostname","on","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar MqttClient = require('../client')\nvar Store = require('../store')\nvar url = require('url')\nvar xtend = require('xtend')\nvar debug = require('debug')('mqttjs')\n\nvar protocols = {}\n\n// eslint-disable-next-line camelcase\nif ((typeof process !== 'undefined' && process.title !== 'browser') || typeof __webpack_require__ !== 'function') {\n  protocols.mqtt = require('./tcp')\n  protocols.tcp = require('./tcp')\n  protocols.ssl = require('./tls')\n  protocols.tls = require('./tls')\n  protocols.mqtts = require('./tls')\n} else {\n  protocols.wx = require('./wx')\n  protocols.wxs = require('./wx')\n\n  protocols.ali = require('./ali')\n  protocols.alis = require('./ali')\n}\n\nprotocols.ws = require('./ws')\nprotocols.wss = require('./ws')\n\n/**\n * Parse the auth attribute and merge username and password in the options object.\n *\n * @param {Object} [opts] option object\n */\nfunction parseAuthOptions (opts) {\n  var matches\n  if (opts.auth) {\n    matches = opts.auth.match(/^(.+):(.+)$/)\n    if (matches) {\n      opts.username = matches[1]\n      opts.password = matches[2]\n    } else {\n      opts.username = opts.auth\n    }\n  }\n}\n\n/**\n * connect - connect to an MQTT broker.\n *\n * @param {String} [brokerUrl] - url of the broker, optional\n * @param {Object} opts - see MqttClient#constructor\n */\nfunction connect (brokerUrl, opts) {\n  debug('connecting to an MQTT broker...')\n  if ((typeof brokerUrl === 'object') && !opts) {\n    opts = brokerUrl\n    brokerUrl = null\n  }\n\n  opts = opts || {}\n\n  if (brokerUrl) {\n    var parsed = url.parse(brokerUrl, true)\n    if (parsed.port != null) {\n      parsed.port = Number(parsed.port)\n    }\n\n    opts = xtend(parsed, opts)\n\n    if (opts.protocol === null) {\n      throw new Error('Missing protocol')\n    }\n\n    opts.protocol = opts.protocol.replace(/:$/, '')\n  }\n\n  // merge in the auth options if supplied\n  parseAuthOptions(opts)\n\n  // support clientId passed in the query string of the url\n  if (opts.query && typeof opts.query.clientId === 'string') {\n    opts.clientId = opts.query.clientId\n  }\n\n  if (opts.cert && opts.key) {\n    if (opts.protocol) {\n      if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n        switch (opts.protocol) {\n          case 'mqtt':\n            opts.protocol = 'mqtts'\n            break\n          case 'ws':\n            opts.protocol = 'wss'\n            break\n          case 'wx':\n            opts.protocol = 'wxs'\n            break\n          case 'ali':\n            opts.protocol = 'alis'\n            break\n          default:\n            throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!')\n        }\n      }\n    } else {\n      // A cert and key was provided, however no protocol was specified, so we will throw an error.\n      throw new Error('Missing secure protocol key')\n    }\n  }\n\n  if (!protocols[opts.protocol]) {\n    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1\n    opts.protocol = [\n      'mqtt',\n      'mqtts',\n      'ws',\n      'wss',\n      'wx',\n      'wxs',\n      'ali',\n      'alis'\n    ].filter(function (key, index) {\n      if (isSecure && index % 2 === 0) {\n        // Skip insecure protocols when requesting a secure one.\n        return false\n      }\n      return (typeof protocols[key] === 'function')\n    })[0]\n  }\n\n  if (opts.clean === false && !opts.clientId) {\n    throw new Error('Missing clientId for unclean clients')\n  }\n\n  if (opts.protocol) {\n    opts.defaultProtocol = opts.protocol\n  }\n\n  function wrapper (client) {\n    if (opts.servers) {\n      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n        client._reconnectCount = 0\n      }\n\n      opts.host = opts.servers[client._reconnectCount].host\n      opts.port = opts.servers[client._reconnectCount].port\n      opts.protocol = (!opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol)\n      opts.hostname = opts.host\n\n      client._reconnectCount++\n    }\n\n    debug('calling streambuilder for', opts.protocol)\n    return protocols[opts.protocol](client, opts)\n  }\n  var client = new MqttClient(wrapper, opts)\n  client.on('error', function () { /* Automatically set up client error handling */ })\n  return client\n}\n\nmodule.exports = connect\nmodule.exports.connect = connect\nmodule.exports.MqttClient = MqttClient\nmodule.exports.Store = Store\n"]},"metadata":{},"sourceType":"script"}